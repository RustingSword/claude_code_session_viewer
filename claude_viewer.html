<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Claude / Codex ä¼šè¯æŸ¥çœ‹å™¨</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify/dist/purify.min.js"></script>
    <style>
      mark {
        background-color: #fef08a;
        padding: 0 2px;
        border-radius: 2px;
      }
      .markdown-content h1 { font-size: 1.5em; font-weight: bold; margin: 0.5em 0; }
      .markdown-content h2 { font-size: 1.3em; font-weight: bold; margin: 0.5em 0; }
      .markdown-content h3 { font-size: 1.1em; font-weight: bold; margin: 0.5em 0; }
      .markdown-content code { background: #f1f5f9; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; white-space: pre-wrap; overflow-wrap: anywhere; word-break: break-word; }
      .markdown-content pre { background: #f1f5f9; padding: 1em; border-radius: 6px; overflow-x: auto; }
      .markdown-content pre code { background: none; padding: 0; }
      .markdown-content ul { list-style: disc; margin-left: 1.5em; }
      .markdown-content ol { list-style: decimal; margin-left: 1.5em; }
      .markdown-content a { color: #3b82f6; text-decoration: underline; }
      .markdown-content { overflow-wrap: anywhere; }

      /* æ”¹è¿› pre æ ‡ç­¾çš„æ–‡æœ¬æ¢è¡Œ */
      pre {
        white-space: pre-wrap;
        word-wrap: break-word;
        overflow-wrap: break-word;
      }

      /* ç¡®ä¿ä»£ç å—ä¸ä¼šè¶…å‡ºå®¹å™¨ */
      pre code {
        display: block;
        max-width: 100%;
      }
    </style>
  </head>
  <body class="bg-slate-50 text-slate-900">
    <div class="flex h-screen">
      <!-- å·¦ä¾§è¾¹æ  -->
      <aside class="w-80 shrink-0 border-r bg-white flex flex-col">
        <div class="p-5 border-b">
          <div class="text-lg font-semibold">Claude / Codex ä¼šè¯æŸ¥çœ‹å™¨</div>
          <div class="text-xs text-slate-500 mt-1">
            æœ¬åœ°ä¼šè¯å†å²æµè§ˆå™¨
          </div>
          <label class="block text-xs text-slate-500 mt-4">é¡¹ç›®</label>
          <select
            id="projectSelect"
            class="mt-2 w-full rounded-lg border border-slate-200 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
          ></select>
        </div>
        <div class="px-5 pt-4 text-xs uppercase text-slate-400 tracking-wider">
          ä¼šè¯åˆ—è¡¨
        </div>
        <div id="sessionList" class="flex-1 overflow-y-scroll px-3 pb-4"></div>
      </aside>

      <!-- ä¸»å†…å®¹åŒº -->
      <main class="flex-1 min-w-0 flex flex-col">
        <!-- å›ºå®šé¡¶éƒ¨åŒºåŸŸ -->
        <div class="flex-shrink-0 bg-white">
          <!-- æœç´¢æ  -->
          <div class="border-b p-5">
            <div class="flex items-center gap-3">
              <input
                id="searchInput"
                type="text"
                placeholder="æœç´¢æ¶ˆæ¯å†…å®¹..."
                class="flex-1 rounded-lg border border-slate-200 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
              />
              <label class="flex items-center gap-2 text-sm text-slate-600">
                <span>ç±»å‹</span>
                <select
                  id="searchSource"
                  class="rounded-lg border border-slate-200 px-2 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                  <option value="">å…¨éƒ¨</option>
                  <option value="claude_code">Claude Code</option>
                  <option value="codex">Codex</option>
                </select>
              </label>
              <label class="flex items-center gap-2 text-sm text-slate-600">
                <input type="checkbox" id="searchCurrentProjectOnly" class="rounded" />
                <span>ä»…å½“å‰é¡¹ç›®</span>
              </label>
              <label class="flex items-center gap-2 text-sm text-slate-600">
                <input type="checkbox" id="searchCurrentSessionOnly" class="rounded" />
                <span>ä»…å½“å‰ä¼šè¯</span>
              </label>
              <button
                id="searchBtn"
                class="rounded-lg bg-indigo-600 px-4 py-2 text-sm font-medium text-white hover:bg-indigo-700"
              >
                æœç´¢
              </button>
              <button
                id="clearSearchBtn"
                class="rounded-lg border border-slate-200 px-4 py-2 text-sm font-medium text-slate-600 hover:bg-slate-50"
              >
                æ¸…é™¤
              </button>
            </div>
            <div id="searchMeta" class="mt-2 text-xs text-slate-500"></div>
            <div id="indexStatus" class="mt-1 text-xs text-slate-500"></div>
          </div>

          <!-- ä¼šè¯å…ƒä¿¡æ¯ -->
          <div id="sessionMeta" class="border-b p-4 text-sm text-slate-500"></div>
        </div>

        <!-- å¯æ»šåŠ¨æ¶ˆæ¯åˆ—è¡¨åŒºåŸŸ -->
        <div class="flex-1 min-w-0 overflow-y-auto p-6">
          <div id="messageList" class="space-y-4"></div>

          <!-- æœç´¢ç»“æœ -->
          <div id="searchResults" class="hidden space-y-3"></div>

          <!-- åŠ è½½æ›´å¤šæŒ‰é’® -->
          <button
            id="loadMoreBtn"
            class="mt-6 hidden rounded-lg border border-slate-200 px-4 py-2 text-sm font-medium text-slate-700 hover:bg-slate-50"
          >
            åŠ è½½æ›´å¤š
          </button>
        </div>
      </main>
    </div>

    <script>
      // DOM å…ƒç´ å¼•ç”¨
      const projectSelect = document.getElementById("projectSelect");
      const sessionList = document.getElementById("sessionList");
      const messageList = document.getElementById("messageList");
      const sessionMeta = document.getElementById("sessionMeta");
      const searchInput = document.getElementById("searchInput");
      const searchBtn = document.getElementById("searchBtn");
      const clearSearchBtn = document.getElementById("clearSearchBtn");
      const searchMeta = document.getElementById("searchMeta");
      const indexStatus = document.getElementById("indexStatus");
      const searchResults = document.getElementById("searchResults");
      const searchSource = document.getElementById("searchSource");
      const loadMoreBtn = document.getElementById("loadMoreBtn");
      const searchCurrentProjectOnly = document.getElementById("searchCurrentProjectOnly");
      const searchCurrentSessionOnly = document.getElementById("searchCurrentSessionOnly");

      // åº”ç”¨çŠ¶æ€
      const state = {
        projects: [],
        currentProject: { source: "claude_code", project: "" },
        currentProjectKey: "",
        sessions: [],
        currentSessionId: "",
        sessionStartOffset: 0,
        offset: 0,
        limit: 200,
        hasMore: false,
        searchQuery: "",
        searchOffset: 0,
        searchHasMore: false,
        searchTotal: 0,
        expandedSessions: new Set(), // è·Ÿè¸ªå±•å¼€çš„ä¸»ä¼šè¯ID
        roleFilters: { user: true, assistant: true, tool: true, other: true },
      };
      let suppressUrlSync = false;

      function readUrlState() {
        const params = new URLSearchParams(window.location.search || "");
        const rolesParam = (params.get("roles") || "").trim();
        const roles = rolesParam
          ? new Set(rolesParam.split(",").map((s) => s.trim()).filter(Boolean))
          : null;
        return {
          source: params.get("src") || "",
          project: params.get("project") || "",
          sessionId: params.get("session") || "",
          view: params.get("view") || "",
          q: params.get("q") || "",
          focus: params.get("focus") || "",
          offset: params.get("offset") ? Number(params.get("offset")) : NaN,
          projectOnly: params.get("projectOnly") === "1",
          sessionOnly: params.get("sessionOnly") === "1",
          searchSource: params.get("searchSource") || "",
          roles,
        };
      }

      function buildUrl(extra = {}) {
        const params = new URLSearchParams();
        const src = state.currentProject?.source || "claude_code";
        const project = state.currentProject?.project || "";
        if (src) params.set("src", src);
        if (project) params.set("project", project);
        if (state.currentSessionId) params.set("session", state.currentSessionId);
        params.set("view", isSearchView() ? "search" : "session");
        if (isSearchView() && state.searchQuery) params.set("q", state.searchQuery);
        if (searchCurrentProjectOnly.checked) params.set("projectOnly", "1");
        if (searchCurrentSessionOnly.checked) params.set("sessionOnly", "1");
        if (searchSource.value) params.set("searchSource", searchSource.value);
        if (state.sessionStartOffset) params.set("offset", String(state.sessionStartOffset));
        if (extra.focus) params.set("focus", String(extra.focus));
        const rf = state.roleFilters || {};
        const allOn = rf.user && rf.assistant && rf.tool && rf.other;
        if (!allOn) {
          const enabled = [];
          if (rf.user) enabled.push("user");
          if (rf.assistant) enabled.push("assistant");
          if (rf.tool) enabled.push("tool");
          if (rf.other) enabled.push("other");
          params.set("roles", enabled.join(","));
        }
        return `${window.location.pathname}?${params.toString()}`;
      }

      function syncUrl(extra = {}) {
        if (suppressUrlSync) return;
        try {
          window.history.replaceState(null, "", buildUrl(extra));
        } catch {
          // ignore
        }
      }

      function pushUrl(extra = {}) {
        if (suppressUrlSync) return;
        try {
          window.history.pushState(null, "", buildUrl(extra));
        } catch {
          // ignore
        }
      }

      // ä»£ç å—å¤åˆ¶ï¼šé¿å…æŠŠå¤§æ–‡æœ¬å¡è¿› data-* å±æ€§
      let copySeq = 0;
      const copyStore = new Map(); // id -> string

      // å·¥å…·å‡½æ•°
      function formatTimestamp(timestamp) {
        if (!timestamp) return "";
        try {
          const date = new Date(timestamp);
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          const hours = String(date.getHours()).padStart(2, "0");
          const minutes = String(date.getMinutes()).padStart(2, "0");
          const seconds = String(date.getSeconds()).padStart(2, "0");
          return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        } catch {
          return timestamp;
        }
      }

      function escapeHtml(text) {
        return String(text || "")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function escapeRegex(text) {
        return text.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }

      function renderMarkdown(text) {
        const raw = marked.parse(String(text || ""));
        // DOMPurify may not be available (e.g. offline). Fallback: render as plain text.
        if (typeof window.DOMPurify === "undefined") {
          return escapeHtml(String(text || "")).replace(/\n/g, "<br />");
        }
        return window.DOMPurify.sanitize(raw);
      }

      function highlight(text, query) {
        const safe = escapeHtml(text || "");
        if (!query) return safe;
        const terms = query.trim().split(/\s+/).filter(Boolean);
        if (!terms.length) return safe;
        let out = safe;
        for (const term of terms) {
          const regex = new RegExp(escapeRegex(term), "ig");
          out = out.replace(regex, (match) => `<mark>${match}</mark>`);
        }
        return out;
      }

      function setIndexStatusText(text, isError = false) {
        if (!indexStatus) return;
        indexStatus.className = `mt-1 text-xs ${isError ? "text-red-600" : "text-slate-500"}`;
        indexStatus.textContent = text || "";
      }

      function formatIndexStatus(s) {
        const state = s?.state || "idle";
        if (state === "running") {
          const done = Number(s?.processed_files || 0);
          const total = Number(s?.total_files || 0);
          return total ? `ç´¢å¼•æ„å»ºä¸­â€¦ ${done}/${total}` : "ç´¢å¼•æ„å»ºä¸­â€¦";
        }
        if (state === "error") {
          return `ç´¢å¼•å¤±è´¥ï¼š${s?.last_error || "unknown"}`;
        }
        if (state === "ready") {
          return "";
        }
        return "";
      }

      async function fetchIndexStatus() {
        const res = await fetch("/api/index/status");
        if (!res.ok) return null;
        const data = await res.json();
        return data?.status || null;
      }

      async function waitForIndexReady({ timeoutMs = 300000 } = {}) {
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
          const status = await fetchIndexStatus();
          if (status) {
            const text = formatIndexStatus(status);
            if (text) setIndexStatusText(text, status.state === "error");
            if (status.state === "ready") {
              setIndexStatusText("");
              return;
            }
            if (status.state === "error") {
              throw new Error(status.last_error || "ç´¢å¼•å¤±è´¥");
            }
          }
          await new Promise((r) => setTimeout(r, 800));
        }
        throw new Error("ç­‰å¾…ç´¢å¼•å®Œæˆè¶…æ—¶");
      }

      async function api(path, { retryOnIndex = true } = {}) {
        const res = await fetch(path);
        if (res.status === 503 && retryOnIndex) {
          // åç«¯åœ¨é‡å»º/åˆ·æ–°ç´¢å¼•æ—¶ä¼šè¿”å› 503ï¼Œå‰ç«¯è½®è¯¢è¿›åº¦åè‡ªåŠ¨é‡è¯•ä¸€æ¬¡
          let payload = null;
          try {
            payload = await res.json();
          } catch {
            payload = null;
          }
          // FastAPI: {"detail": {...}}
          const detail = payload && typeof payload === "object" && "detail" in payload ? payload.detail : payload;
          const code = detail?.code || "indexing";
          if (code === "indexing" || code === "index_error") {
            setIndexStatusText(formatIndexStatus(detail?.status || { state: "running" }), code === "index_error");
            await waitForIndexReady();
            const out = await api(path, { retryOnIndex: false });
            setIndexStatusText("");
            return out;
          }
        }
        if (!res.ok) {
          throw new Error(`è¯·æ±‚å¤±è´¥: ${res.status}`);
        }
        const data = await res.json();
        // é˜²æ­¢â€œç´¢å¼•æ„å»ºä¸­â€¦â€æ–‡æ¡ˆæ®‹ç•™
        setIndexStatusText("");
        return data;
      }

      async function copyToClipboard(text) {
        const value = String(text || "");
        if (!value) return false;
        try {
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(value);
            return true;
          }
        } catch {
          // ignore and fallback
        }

        // Fallback: execCommand
        try {
          const ta = document.createElement("textarea");
          ta.value = value;
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          ta.style.top = "0";
          ta.setAttribute("readonly", "true");
          document.body.appendChild(ta);
          ta.select();
          const ok = document.execCommand("copy");
          document.body.removeChild(ta);
          return Boolean(ok);
        } catch {
          return false;
        }
      }

      function sourceLabel(source) {
        return source === "codex" ? "[Codex]" : "[Claude Code]";
      }

      function makeProjectKey({ source, project }) {
        return JSON.stringify({ source: source || "claude_code", project: project || "" });
      }

      function parseProjectKey(key) {
        try {
          const parsed = JSON.parse(key || "{}");
          return {
            source: parsed.source || "claude_code",
            project: parsed.project || "",
          };
        } catch {
          // Fallback for old format
          return { source: "claude_code", project: key || "" };
        }
      }

      // æ¸²æŸ“å‡½æ•°
      function renderProjects() {
        projectSelect.innerHTML = "";
        if (!state.projects.length) {
          const option = document.createElement("option");
          option.value = "";
          option.textContent = "æœªæ‰¾åˆ°é¡¹ç›®";
          projectSelect.appendChild(option);
          return;
        }
        for (const project of state.projects) {
          const option = document.createElement("option");
          const src = project.source || "claude_code";
          option.value = makeProjectKey({ source: src, project: project.project });
          option.textContent = `${sourceLabel(src)} ${project.project} (${project.session_count})`;
          projectSelect.appendChild(option);
        }
        projectSelect.value = state.currentProjectKey;
      }

      /**
       * åˆ›å»ºä¼šè¯åˆ—è¡¨é¡¹
       * ä½¿ç”¨ data-* å±æ€§è€Œä¸æ˜¯é—­åŒ…ï¼Œé…åˆäº‹ä»¶å§”æ‰˜
       * @param {Object} session - ä¼šè¯å¯¹è±¡
       * @param {boolean} isActive - æ˜¯å¦ä¸ºå½“å‰æ¿€æ´»ä¼šè¯
       * @param {boolean} isSubagent - æ˜¯å¦ä¸ºå­ä¼šè¯
       * @param {boolean} hasSubagents - æ˜¯å¦æœ‰å­ä¼šè¯
       * @param {boolean} isExpanded - å­ä¼šè¯æ˜¯å¦å±•å¼€
       */
      function createSessionListItem(session, isActive, isSubagent = false, hasSubagents = false, isExpanded = false) {
        const wrapper = document.createElement("div");

        // åŸºç¡€æ ·å¼
        let wrapperClass = "rounded-lg border border-slate-200 bg-white mb-3 shadow-sm transition-colors";

        // å­ä¼šè¯æ ·å¼ï¼šç¼©è¿›å’Œä¸åŒçš„è§†è§‰æ•ˆæœ
        if (isSubagent) {
          wrapperClass = "ml-6 rounded-lg border border-slate-200 bg-slate-50 mb-2 shadow-sm transition-colors";
        }

        wrapper.className = wrapperClass;

        if (isActive) {
          wrapper.classList.add("border-indigo-500", "shadow");
        }

        // ä¸»ä¼šè¯åŒºåŸŸï¼ˆå¯ç‚¹å‡»æ‰“å¼€ä¼šè¯ï¼‰
        const mainArea = document.createElement("div");
        mainArea.className = "cursor-pointer p-3 hover:bg-slate-50 rounded-lg";
        mainArea.dataset.action = "open-session";
        mainArea.dataset.sessionId = session.session_id || "";

        // æ„å»ºä¼šè¯ä¿¡æ¯HTML
        // å¯¹äºcodexä¼šè¯ï¼Œæ˜¾ç¤ºæ›´å¤šä¿¡æ¯ä»¥ä¾¿åŒºåˆ†
        let sessionIdDisplay;
        const fullSessionId = session.session_id || "";
        if (fullSessionId.startsWith("rollout-")) {
          // codexä¼šè¯ï¼šæ˜¾ç¤ºæ—¶é—´æˆ³éƒ¨åˆ† (rollout-2026-01-27T06-57-15)
          const parts = fullSessionId.split("-");
          if (parts.length >= 5) {
            sessionIdDisplay = escapeHtml(parts.slice(0, 5).join("-"));
          } else {
            sessionIdDisplay = escapeHtml(fullSessionId.slice(0, 30));
          }
        } else {
          // claude codeä¼šè¯ï¼šæ˜¾ç¤ºå‰8ä¸ªå­—ç¬¦
          sessionIdDisplay = escapeHtml(fullSessionId.slice(0, 8));
        }
        const subagentIcon = isSubagent ? '<span class="text-slate-400 mr-1">â†³</span>' : '';

        // åªå¯¹ä¸»ä¼šè¯ä¿ç•™æŒ‰é’®æ§½ä½ï¼›å­ä¼šè¯ä¸éœ€è¦
        const toggleSlotHtml = isSubagent ? "" : `<div class="ml-2 w-6 h-6 flex items-center justify-center flex-shrink-0">${hasSubagents ? `<button type="button" class="w-6 h-6 hover:bg-slate-200 rounded transition-colors" data-action="toggle-subagents" data-session-id="${escapeHtml(session.session_id || "")}" aria-label="å±•å¼€/æŠ˜å å­ä¼šè¯"><span class="inline-block w-4 text-center text-slate-600 text-sm">${isExpanded ? 'â–¼' : 'â–¶'}</span></button>` : ""}</div>`;

        mainArea.innerHTML = `
          <div class="flex items-start">
            <div class="flex-1 min-w-0">
              <div class="text-sm font-semibold text-slate-700 flex items-center">
                ${subagentIcon}${sessionIdDisplay}
                ${isSubagent ? '<span class="ml-2 text-[10px] px-1.5 py-0.5 bg-purple-100 text-purple-700 rounded">å­ä¼šè¯</span>' : ''}
              </div>
              <div class="text-xs text-slate-500 mt-1" style="display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">
                ${escapeHtml(session.summary || "æ— æ‘˜è¦")}
              </div>
              <div class="mt-2 text-[11px] text-slate-400 flex justify-between">
                <span>${escapeHtml(session.updated_at || "")}</span>
                <span>${session.message_count || 0} æ¡æ¶ˆæ¯</span>
              </div>
            </div>
            ${toggleSlotHtml}
          </div>
        `;

        wrapper.appendChild(mainArea);
        return wrapper;
      }

      /**
       * åˆ›å»ºæœç´¢ç»“æœå¡ç‰‡
       * ä½¿ç”¨ data-* å±æ€§è€Œä¸æ˜¯é—­åŒ…ï¼Œé…åˆäº‹ä»¶å§”æ‰˜
       */
      function createSearchResultCard(result) {
        const card = document.createElement("div");
        card.className =
          "rounded-xl border border-slate-200 bg-white p-4 shadow-sm hover:shadow-md transition-shadow";

        const src = result.source || "claude_code";
        card.innerHTML = `
          <div class="flex items-center justify-between text-xs text-slate-500">
            <span class="font-semibold text-slate-700">${escapeHtml(
              `${sourceLabel(src)} ${result.project}`
            )}</span>
            <span>${formatTimestamp(result.timestamp)}</span>
          </div>
          <div class="mt-2 text-xs text-slate-400">
            ä¼šè¯ ${escapeHtml(result.session_id)}
          </div>
          <div class="mt-3 text-sm text-slate-800 whitespace-pre-wrap break-words">
            ${highlight(result.excerpt || "", state.searchQuery)}
          </div>
          <div class="mt-3 flex gap-3">
            <button
              type="button"
              class="text-xs font-medium text-indigo-600 hover:text-indigo-800"
              data-action="jump-to-message"
              data-session="${escapeHtml(result.session_id)}"
              data-project="${escapeHtml(result.project)}"
              data-source="${escapeHtml(src)}"
              data-event-id="${escapeHtml(result.event_id || "")}"
              data-line-no="${escapeHtml(result.line_no ?? "")}"
              data-timestamp="${escapeHtml(result.timestamp)}"
            >
              è·³è½¬åˆ°æ¶ˆæ¯ â†’
            </button>
            <button
              type="button"
              class="text-xs font-medium text-slate-600 hover:text-slate-800"
              data-action="open-session"
              data-session="${escapeHtml(result.session_id)}"
              data-project="${escapeHtml(result.project)}"
              data-source="${escapeHtml(src)}"
            >
              æ‰“å¼€ä¼šè¯ â†’
            </button>
          </div>
        `;

        return card;
      }

      /**
       * æ„å»ºä¼šè¯æ ‘å½¢ç»“æ„
       * @param {Array} sessions - æ‰å¹³çš„ä¼šè¯åˆ—è¡¨
       * @returns {Array} æ ‘å½¢ç»“æ„çš„ä¼šè¯åˆ—è¡¨
       */
      function buildSessionTree(sessions) {
        const tree = [];
        const sessionMap = new Map();

        // ç¬¬ä¸€éï¼šå»ºç«‹æ˜ å°„
        for (const session of sessions) {
          sessionMap.set(session.session_id, {
            ...session,
            subagents: []
          });
        }

        // ç¬¬äºŒéï¼šæ„å»ºæ ‘å½¢ç»“æ„
        for (const session of sessions) {
          const node = sessionMap.get(session.session_id);
          if (session.parent_session_id) {
            // è¿™æ˜¯å­ä¼šè¯ï¼Œæ·»åŠ åˆ°çˆ¶ä¼šè¯çš„ subagents æ•°ç»„
            const parent = sessionMap.get(session.parent_session_id);
            if (parent) {
              parent.subagents.push(node);
            } else {
              // çˆ¶ä¼šè¯ä¸å­˜åœ¨ï¼ˆå¯èƒ½è¢«è¿‡æ»¤æ‰äº†ï¼‰ï¼Œä½œä¸ºé¡¶å±‚ä¼šè¯å¤„ç†
              tree.push(node);
            }
          } else {
            // è¿™æ˜¯ä¸»ä¼šè¯ï¼Œæ·»åŠ åˆ°é¡¶å±‚
            tree.push(node);
          }
        }

        return tree;
      }

      function renderSessions() {
        sessionList.innerHTML = "";
        if (!state.sessions.length) {
          sessionList.innerHTML =
            '<div class="p-4 text-sm text-slate-400">æœªæ‰¾åˆ°ä¼šè¯</div>';
          return;
        }

        // æ„å»ºæ ‘å½¢ç»“æ„
        const sessionTree = buildSessionTree(state.sessions);

        // ä½¿ç”¨ DocumentFragment å‡å°‘é‡æ’é‡ç»˜
        const fragment = document.createDocumentFragment();

        for (const session of sessionTree) {
          const isActive = session.session_id === state.currentSessionId;
          const hasSubagents = session.subagents && session.subagents.length > 0;
          const isExpanded = state.expandedSessions.has(session.session_id);

          // æ¸²æŸ“ä¸»ä¼šè¯
          fragment.appendChild(
            createSessionListItem(session, isActive, false, hasSubagents, isExpanded)
          );

          // å¦‚æœæœ‰å­ä¼šè¯ä¸”å·²å±•å¼€ï¼Œæ¸²æŸ“å­ä¼šè¯
          if (hasSubagents && isExpanded) {
            for (const subagent of session.subagents) {
              const isSubActive = subagent.session_id === state.currentSessionId;
              fragment.appendChild(
                createSessionListItem(subagent, isSubActive, true, false, false)
              );
            }
          }
        }

        sessionList.appendChild(fragment);
      }

      function renderSessionMeta() {
        const session = state.sessions.find(
          (s) => s.session_id === state.currentSessionId
        );
        if (!session) {
          sessionMeta.innerHTML = "";
          return;
        }
        const rf = state.roleFilters || { user: true, assistant: true, tool: true, other: true };
        sessionMeta.innerHTML = `
          <div class="flex flex-col gap-2">
            <div class="flex items-center justify-between">
              <div class="flex flex-wrap gap-3 text-xs text-slate-500">
                <span class="font-semibold text-slate-700">${escapeHtml(
                  session.session_id
                )}</span>
                <span>${escapeHtml(sourceLabel(state.currentProject?.source))}</span>
                <span>ä¼šè¯æ—¶é—´: ${formatTimestamp(session.started_at)} ~ ${formatTimestamp(session.updated_at)}</span>
                <span>æ¶ˆæ¯æ•°: ${session.message_count || 0}</span>
                <span>${escapeHtml(session.cwd || "")}</span>
                <span>${escapeHtml(session.git_branch || "")}</span>
              </div>
              <div class="ml-4 flex items-center gap-2 flex-shrink-0">
                <button
                  id="expandAllBtn"
                  class="px-3 py-1.5 text-xs font-medium text-slate-700 border border-slate-200 hover:bg-slate-50 rounded-lg transition-colors whitespace-nowrap"
                  title="å±•å¼€å½“å‰è§†å›¾é‡Œçš„æ‰€æœ‰æŠ˜å å†…å®¹"
                >
                  å±•å¼€å…¨éƒ¨
                </button>
                <button
                  id="collapseAllBtn"
                  class="px-3 py-1.5 text-xs font-medium text-slate-700 border border-slate-200 hover:bg-slate-50 rounded-lg transition-colors whitespace-nowrap"
                  title="æŠ˜å å½“å‰è§†å›¾é‡Œçš„æ‰€æœ‰æŠ˜å å†…å®¹"
                >
                  æŠ˜å å…¨éƒ¨
                </button>
                <button
                  id="refreshSessionBtn"
                  class="px-3 py-1.5 text-xs font-medium text-white bg-indigo-600 hover:bg-indigo-700 rounded-lg transition-colors whitespace-nowrap flex items-center gap-1.5"
                  title="åˆ·æ–°å½“å‰ä¼šè¯"
                >
                  <span>ğŸ”„</span>
                  <span>åˆ·æ–°</span>
                </button>
              </div>
            </div>

            <div class="flex flex-wrap items-center gap-3 text-xs text-slate-600">
              <span class="text-slate-400">æ˜¾ç¤º</span>
              <label class="inline-flex items-center gap-2 select-none">
                <input type="checkbox" class="rounded" data-action="role-filter" data-role="user" ${rf.user ? "checked" : ""} />
                <span>user</span>
              </label>
              <label class="inline-flex items-center gap-2 select-none">
                <input type="checkbox" class="rounded" data-action="role-filter" data-role="assistant" ${rf.assistant ? "checked" : ""} />
                <span>assistant</span>
              </label>
              <label class="inline-flex items-center gap-2 select-none">
                <input type="checkbox" class="rounded" data-action="role-filter" data-role="tool" ${rf.tool ? "checked" : ""} />
                <span>tool</span>
              </label>
              <label class="inline-flex items-center gap-2 select-none">
                <input type="checkbox" class="rounded" data-action="role-filter" data-role="other" ${rf.other ? "checked" : ""} />
                <span>other</span>
              </label>
            </div>
          </div>
        `;
      }

      function parseContent(content) {
        if (!content) return [];
        try {
          const parsed = JSON.parse(content);
          return Array.isArray(parsed) ? parsed : [{ type: "text", text: String(content) }];
        } catch {
          return [{ type: "text", text: String(content) }];
        }
      }

      /**
       * è§£ææ—§æ ¼å¼çš„å·¥å…·è°ƒç”¨ï¼ˆMarkdown æ ¼å¼ï¼‰
       * æ—§æ ¼å¼ï¼š**Tool:** `name`\n\n```json\n{...}\n```
       */
      function parseLegacyToolCall(markdown) {
        const text = String(markdown || "");
        const nameMatch = text.match(/\*\*Tool:\*\*\s*`([^`]+)`/);
        const name = (nameMatch && nameMatch[1]) ? nameMatch[1] : "å·¥å…·è°ƒç”¨";

        // æå– JSON ä»£ç å—ï¼ˆæ”¯æŒ \n å’Œ \r\nï¼‰
        const jsonFence = text.match(/```json\s*[\r\n]+([\s\S]*?)[\r\n]+```/);
        let input = {};
        if (jsonFence && jsonFence[1]) {
          const raw = jsonFence[1].trim();
          if (raw) {
            try {
              input = JSON.parse(raw);
            } catch {
              input = { _raw: raw };
            }
          }
        } else {
          input = { _raw: text };
        }

        return { type: "tool_use", name, input };
      }

      /**
       * è§£ææ—§æ ¼å¼çš„å·¥å…·è¾“å‡ºï¼ˆMarkdown æ ¼å¼ï¼‰
       * æ—§æ ¼å¼ï¼š```json\n{...}\n``` æˆ– ```\n...\n```
       */
      function parseLegacyToolOutput(markdown) {
        const text = String(markdown || "");

        // ä¼˜å…ˆå°è¯• JSON ä»£ç å—ï¼ˆæ”¯æŒ \n å’Œ \r\nï¼‰
        const jsonFence = text.match(/```json\s*[\r\n]+([\s\S]*?)[\r\n]+```/);
        if (jsonFence && jsonFence[1]) {
          const raw = jsonFence[1].trim();
          if (!raw) return { type: "tool_result", content: "" };
          try {
            return { type: "tool_result", content: JSON.parse(raw) };
          } catch {
            return { type: "tool_result", content: raw };
          }
        }

        // å…¶æ¬¡å°è¯•æ™®é€šä»£ç å—ï¼ˆæ”¯æŒ \n å’Œ \r\nï¼‰
        const anyFence = text.match(/```\s*[\r\n]+([\s\S]*?)[\r\n]+```/);
        if (anyFence && anyFence[1]) {
          return { type: "tool_result", content: anyFence[1].trim() };
        }

        return { type: "tool_result", content: text };
      }

      /**
       * è·å–æ¶ˆæ¯çš„å†…å®¹å—ï¼ˆç»Ÿä¸€æ–°æ—§æ ¼å¼ï¼‰
       *
       * ä¼˜å…ˆä½¿ç”¨æ–°çš„ blocks å­—æ®µï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è§£æ content å­—æ®µã€‚
       * åŒæ—¶å¤„ç†æ—§çš„äº‹ä»¶çº§ç±»å‹ï¼ˆreasoning/tool_call/tool_outputï¼‰ã€‚
       */
      function getItemBlocks(item) {
        // ä¼˜å…ˆä½¿ç”¨æ–°çš„ blocks å­—æ®µ
        if (item && Array.isArray(item.blocks)) {
          return item.blocks;
        }

        // è§£æ content å­—æ®µ
        const blocks = parseContent(item ? item.content : "");

        // å‘åå…¼å®¹ï¼šå°†æ—§çš„äº‹ä»¶çº§ç±»å‹è½¬æ¢ä¸ºç»Ÿä¸€çš„ blocks
        if (item && item.type === "reasoning") {
          // reasoning ç±»å‹ï¼šæå–æ–‡æœ¬å†…å®¹å¹¶è½¬æ¢ä¸º thinking block
          const thinking = blocks
            .map((b) => (b && typeof b === "object" && b.type === "text" ? (b.text || "") : ""))
            .filter(Boolean)
            .join("\n")
            .trim();
          return thinking ? [{ type: "thinking", thinking }] : blocks;
        }

        if (item && item.type === "tool_call") {
          // tool_call ç±»å‹ï¼šè§£æ Markdown æ ¼å¼çš„å·¥å…·è°ƒç”¨
          return [parseLegacyToolCall(item.content)];
        }

        if (item && item.type === "tool_output") {
          // tool_output ç±»å‹ï¼šè§£æ Markdown æ ¼å¼çš„å·¥å…·è¾“å‡º
          return [parseLegacyToolOutput(item.content)];
        }

        return blocks;
      }

      function formatJsonForDisplay(obj) {
        return JSON.stringify(obj, null, 2);
      }

      function unescapeJsonString(str) {
        return str.replace(/\\n/g, '\n').replace(/\\t/g, '\t');
      }

      function renderBox({ collapsible = false, bgClass, borderClass, titleClass = "", title = "", summary = "", bodyHtml }) {
        const containerClass = `mt-2 rounded-lg ${bgClass} border ${borderClass} p-3`;
        if (collapsible) {
          return `
            <details class="${containerClass}">
              <summary class="cursor-pointer text-xs font-semibold ${titleClass} select-none">
                ${summary}
              </summary>
              ${bodyHtml}
            </details>
          `;
        }
        const titleHtml = title
          ? `<div class="text-xs font-semibold ${titleClass}">${title}</div>`
          : "";
        return `
          <div class="${containerClass}">
            ${titleHtml}
            ${bodyHtml}
          </div>
        `;
      }

      function renderCollapsible({ bgClass, borderClass, summaryClass, summary, bodyHtml }) {
        return renderBox({
          collapsible: true,
          bgClass,
          borderClass,
          titleClass: summaryClass,
          summary,
          bodyHtml,
        });
      }

      function renderPanel({ bgClass, borderClass, titleClass, title, bodyHtml }) {
        return renderBox({ bgClass, borderClass, titleClass, title, bodyHtml });
      }

      function renderCodeBlock(content, extraClass = "") {
        const copyId = `cb_${++copySeq}`;
        copyStore.set(copyId, String(content || ""));
        const classes = `mt-2 text-xs text-slate-600 overflow-x-auto whitespace-pre-wrap break-words ${extraClass}`.trim();
        return `
          <div class="relative group">
            <button
              type="button"
              class="absolute top-2 right-2 hidden group-hover:inline-flex items-center rounded-md border border-slate-200 bg-white px-2 py-1 text-[11px] font-medium text-slate-700 hover:bg-slate-50"
              data-action="copy-code"
              data-copy-id="${escapeHtml(copyId)}"
              title="å¤åˆ¶ä»£ç å—å†…å®¹"
            >
              å¤åˆ¶
            </button>
            <pre class="${classes}"><code>${escapeHtml(content)}</code></pre>
          </div>
        `;
      }

      function getRoleClasses(role, type) {
        if (role === "user" || type === "user") {
          return {
            badgeClass: "bg-indigo-600 text-white",
            bubbleClass: "bg-indigo-50 border-indigo-200",
          };
        }
        if (role === "assistant" || type === "assistant") {
          return {
            badgeClass: "bg-emerald-600 text-white",
            bubbleClass: "bg-emerald-50 border-emerald-200",
          };
        }
        if (type === "tool_call") {
          return {
            badgeClass: "bg-purple-600 text-white",
            bubbleClass: "bg-purple-50 border-purple-200",
          };
        }
        if (type === "tool_output" || role === "tool") {
          return {
            badgeClass: "bg-amber-600 text-white",
            bubbleClass: "bg-amber-50 border-amber-200",
          };
        }
        if (type === "reasoning") {
          return {
            badgeClass: "bg-slate-600 text-white",
            bubbleClass: "bg-slate-50 border-slate-200",
          };
        }
        return {
          badgeClass: "bg-slate-200 text-slate-600",
          bubbleClass: "bg-white border-slate-200",
        };
      }

      function renderTextBlock(text) {
        const content = text || "";
        const isSystemMessage = content.includes("<local-command-") || content.includes("<command-") || content.includes("<system-");

        if (isSystemMessage) {
          return renderCollapsible({
            bgClass: "bg-slate-100",
            borderClass: "border-slate-300",
            summaryClass: "text-slate-600",
            summary: `ğŸ“‹ ç³»ç»Ÿæ¶ˆæ¯ (${content.length} å­—ç¬¦)`,
            bodyHtml: `<div class="mt-2 text-xs text-slate-600 whitespace-pre-wrap break-words">${escapeHtml(content)}</div>`,
          });
        }

        if (content.length > 1500) {
          return renderCollapsible({
            bgClass: "bg-slate-50",
            borderClass: "border-slate-200",
            summaryClass: "text-slate-600",
            summary: `ğŸ“„ é•¿æ–‡æœ¬ (${content.length} å­—ç¬¦ï¼Œç‚¹å‡»å±•å¼€)`,
            bodyHtml: `<div class="mt-2 text-sm text-slate-800 markdown-content">${renderMarkdown(content)}</div>`,
          });
        }

        return `<div class="text-sm text-slate-800 markdown-content">${renderMarkdown(content)}</div>`;
      }

      function formatToolResultContent(block) {
        // ä½¿ç”¨ in æ“ä½œç¬¦æ£€æŸ¥ content å­—æ®µæ˜¯å¦å­˜åœ¨ï¼Œè€Œä¸æ˜¯ç”¨ || åˆ¤æ–­
        // è¿™æ ·å¯ä»¥æ­£ç¡®å¤„ç†ç©ºå­—ç¬¦ä¸²ã€0ã€false ç­‰ falsy å€¼
        const content = "content" in block ? block.content : block;
        if (typeof content === "string") {
          try {
            return formatJsonForDisplay(JSON.parse(content));
          } catch {
            return unescapeJsonString(content);
          }
        }
        return formatJsonForDisplay(content);
      }

      function renderToolResult(block) {
        const displayContent = formatToolResultContent(block);
        const isLong = displayContent.length > 2000;
        const bodyHtml = renderCodeBlock(displayContent, isLong ? "max-h-96" : "max-h-60");

        // ç»Ÿä¸€ä½¿ç”¨ <details>/<summary> æŠ˜å ç»„ä»¶
        // çŸ­å†…å®¹é»˜è®¤å±•å¼€ï¼ˆopen å±æ€§ï¼‰ï¼Œé•¿å†…å®¹é»˜è®¤æŠ˜å 
        const openAttr = isLong ? "" : " open";
        return `
          <details class="mt-2 rounded-lg bg-green-50 border border-green-200 p-3"${openAttr}>
            <summary class="cursor-pointer text-xs font-semibold text-green-700 select-none">
              âœ“ å·¥å…·ç»“æœ (${displayContent.length} å­—ç¬¦ï¼Œç‚¹å‡»${isLong ? "å±•å¼€" : "æŠ˜å "})
            </summary>
            ${bodyHtml}
          </details>
        `;
      }

      const contentRenderers = {
        thinking: (block) => renderCollapsible({
          bgClass: "bg-amber-50",
          borderClass: "border-amber-200",
          summaryClass: "text-amber-700",
          summary: "ğŸ’­ æ€è€ƒè¿‡ç¨‹",
          bodyHtml: `<div class="mt-2 text-sm text-slate-700 markdown-content">${renderMarkdown(block.thinking || "")}</div>`,
        }),
        image: (block) => {
          const source = block.source || {};
          const data = source.data || "";
          if (!data) {
            return `<div class="text-sm text-slate-500">å›¾ç‰‡æ•°æ®ç¼ºå¤±</div>`;
          }
          const mediaType = source.media_type || "image/png";
          return renderPanel({
            bgClass: "bg-white",
            borderClass: "border-slate-200",
            titleClass: "text-slate-600 mb-2",
            title: "ğŸ–¼ï¸ å›¾ç‰‡",
            bodyHtml: `<img src="data:${mediaType};base64,${data}" class="max-w-full h-auto rounded" alt="æ¶ˆæ¯å›¾ç‰‡" />`,
          });
        },
        text: (block) => renderTextBlock(block.text),
        tool_use: (block) => {
          // å·¥å…·è°ƒç”¨é»˜è®¤å±•å¼€ï¼ˆå› ä¸ºé€šå¸¸å†…å®¹ä¸é•¿ï¼‰
          const inputJson = formatJsonForDisplay(block.input || {});
          const bodyHtml = renderCodeBlock(inputJson);
          return `
            <details class="mt-2 rounded-lg bg-blue-50 border border-blue-200 p-3" open>
              <summary class="cursor-pointer text-xs font-semibold text-blue-700 select-none">
                ğŸ”§ ${escapeHtml(block.name || "å·¥å…·è°ƒç”¨")}ï¼ˆç‚¹å‡»æŠ˜å ï¼‰
              </summary>
              ${bodyHtml}
            </details>
          `;
        },
        tool_result: renderToolResult,
      };

      function renderContentBlock(block) {
        if (!block || typeof block !== "object") {
          return `<div class="text-sm text-slate-800">${escapeHtml(String(block))}</div>`;
        }

        const type = block.type || "unknown";
        const renderer = Object.hasOwn(contentRenderers, type) ? contentRenderers[type] : null;
        if (renderer) {
          return renderer(block);
        }

        return `<pre class="text-xs text-slate-500 overflow-x-auto whitespace-pre-wrap break-words"><code>${escapeHtml(formatJsonForDisplay(block))}</code></pre>`;
      }

      function renderMessages(items) {
        if (!items.length) {
          messageList.innerHTML =
            '<div class="text-sm text-slate-400">æš‚æ— æ¶ˆæ¯</div>';
          return;
        }
        const fragment = document.createDocumentFragment();
        for (const item of items) {
          const role = item.role || item.type || "event";
          const roleCategory = roleCategoryForItem(item);

          // è·³è¿‡ä¸æ˜¾ç¤ºçš„äº‹ä»¶ç±»å‹
          const skipTypes = ["summary", "file-history-snapshot", "progress"];
          if (item.type === "progress" || (skipTypes.includes(item.type) && !item.content)) {
            continue;
          }

          const { badgeClass, bubbleClass } = getRoleClasses(role, item.type);

          const wrapper = document.createElement("div");
          wrapper.className = `rounded-xl border ${bubbleClass} p-4 shadow-sm`;
          if (item.timestamp) {
            wrapper.dataset.timestamp = item.timestamp;
          }
          wrapper.dataset.roleCategory = roleCategory;
          // æ·»åŠ IDä»¥æ”¯æŒé”šç‚¹è·³è½¬ï¼šä¼˜å…ˆä½¿ç”¨ç¨³å®š event_id
          if (item.id) {
            wrapper.id = `msg-${item.id}`;
          } else if (item.timestamp) {
            wrapper.id = `msg-${item.timestamp}`;
          }

          // ä½¿ç”¨ç»Ÿä¸€çš„ getItemBlocks() è·å–å†…å®¹å—ï¼ˆæ”¯æŒæ–°æ—§æ ¼å¼ï¼‰
          const contentBlocks = getItemBlocks(item);
          const contentHtml = contentBlocks.map((block) => renderContentBlock(block)).join("");

          // ç¡®å®šæ˜¾ç¤ºæ ‡ç­¾
          let displayLabel = role;
          const linkId = item.id || "";

          // ç»Ÿä¸€çš„å¡ç‰‡ç»“æ„ï¼šæ‰€æœ‰æŠ˜å äº¤äº’éƒ½ç”±å†…å®¹å—çš„ <details>/<summary> æ‰¿æ‹…
          wrapper.innerHTML = `
            <div class="flex items-center justify-between">
              <span class="rounded-full px-2 py-1 text-xs font-semibold ${badgeClass}">
                ${escapeHtml(displayLabel)}
              </span>
              <div class="flex items-center gap-2 text-xs text-slate-400">
                ${
                  linkId
                    ? `<button type="button" class="text-[11px] font-medium text-slate-600 hover:text-slate-800" data-action="copy-permalink" data-event-id="${escapeHtml(linkId)}" title="å¤åˆ¶æ­¤æ¶ˆæ¯é“¾æ¥">ğŸ”—</button>`
                    : ""
                }
                <span>${formatTimestamp(item.timestamp)}</span>
              </div>
            </div>
            <div class="mt-3 space-y-2">
              ${contentHtml}
            </div>
          `;
          fragment.appendChild(wrapper);
        }
        messageList.appendChild(fragment);
        applyMessageRoleFilter();
      }

      function renderSearchResults(results, append = false) {
        if (!append) {
          searchResults.innerHTML = "";
        }
        if (!results.length && !append) {
          searchResults.innerHTML =
            '<div class="text-sm text-slate-400">æœªæ‰¾åˆ°ç»“æœ</div>';
          return;
        }

        // ä½¿ç”¨ DocumentFragment å‡å°‘é‡æ’é‡ç»˜
        const fragment = document.createDocumentFragment();
        for (const result of results) {
          fragment.appendChild(createSearchResultCard(result));
        }
        searchResults.appendChild(fragment);
      }

      function isSearchView() {
        return !searchResults.classList.contains("hidden");
      }

      function toggleAllDetails(open) {
        const container = isSearchView() ? searchResults : messageList;
        const details = container.querySelectorAll("details");
        for (const el of details) {
          el.open = Boolean(open);
        }
      }

      function roleCategoryForItem(item) {
        const role = String(item?.role || "").toLowerCase();
        const type = String(item?.type || "").toLowerCase();
        if (role === "user" || type === "user") return "user";
        if (role === "assistant" || type === "assistant") return "assistant";
        if (role === "tool" || type === "tool_call" || type === "tool_output" || role === "tool_call" || role === "tool_output") return "tool";
        return "other";
      }

      function applyMessageRoleFilter() {
        const rf = state.roleFilters || {};
        for (const el of messageList.children) {
          const cat = el.dataset.roleCategory || "other";
          const visible = Boolean(rf[cat]);
          el.classList.toggle("hidden", !visible);
        }
      }

      async function ensureProjectLoaded(projectObj) {
        const key = makeProjectKey(projectObj);
        if (key === state.currentProjectKey) {
          return;
        }
        state.currentProject = projectObj;
        state.currentProjectKey = key;
        projectSelect.value = key;
        // æœç´¢è·³è½¬æ—¶ä¸è‡ªåŠ¨æ‰“å¼€ç¬¬ä¸€ä¸ªä¼šè¯ï¼Œé¿å…é—ªå±/å¤šä½™è¯·æ±‚
        await loadSessions(projectObj, false);
      }

      function scrollToMessage(targetId) {
        if (!targetId) return;
        setTimeout(() => {
          let msgElement = document.getElementById(`msg-${targetId}`);
          // Fallbackï¼šå¦‚æœ targetId æ˜¯ timestampï¼Œåˆ™å°è¯•æŒ‰ data-timestamp æŸ¥æ‰¾
          if (!msgElement) {
            msgElement = document.querySelector(`[data-timestamp="${CSS.escape(String(targetId))}"]`);
          }
          if (msgElement) {
            msgElement.scrollIntoView({ behavior: "smooth", block: "center" });
            msgElement.style.backgroundColor = "#fef3c7";
            setTimeout(() => {
              msgElement.style.backgroundColor = "";
            }, 2000);
          }
        }, 100);
      }

      async function openSessionFromSearch({ sessionId, project, source, eventId, lineNo, timestamp }) {
        await ensureProjectLoaded({ source: source || "claude_code", project });
        // ä¸ºå‘½ä¸­æ¶ˆæ¯ç•™å‡ºä¸€äº›ä¸Šä¸‹æ–‡ï¼ˆæŒ‰ jsonl è¡Œå·åç§»ï¼‰
        let initialOffset = null;
        const before = 80;
        if (Number.isFinite(lineNo) && lineNo >= 0) {
          initialOffset = Math.max(0, Math.floor(lineNo) - before);
        }

        await loadSession(sessionId, false, initialOffset, "replace");
        showSessionView();
        const target = eventId ? eventId : timestamp;
        if (target) scrollToMessage(target);
        pushUrl({ focus: eventId || "" });
      }

      function setViewMode(showSearch) {
        searchResults.classList.toggle("hidden", !showSearch);
        messageList.classList.toggle("hidden", showSearch);
        if (showSearch) {
          loadMoreBtn.classList.add("hidden");
        }
        syncUrl();
      }

      function showSearchView() {
        setViewMode(true);
      }

      function showSessionView() {
        setViewMode(false);
      }

      function updateSearchScopeUi() {
        const hasSession = Boolean(state.currentSessionId);
        searchCurrentSessionOnly.disabled = !hasSession;
        if (!hasSession && searchCurrentSessionOnly.checked) {
          searchCurrentSessionOnly.checked = false;
        }

        // å¦‚æœé€‰äº†â€œä»…å½“å‰ä¼šè¯â€ï¼Œåˆ™å¼ºåˆ¶ä¾èµ–å½“å‰é¡¹ç›®/sourceï¼Œä¸å…è®¸å†é€‰å…¶ä»–è¿‡æ»¤
        const sessionOnly = searchCurrentSessionOnly.checked;
        searchCurrentProjectOnly.disabled = sessionOnly;
        searchSource.disabled = sessionOnly;
        if (sessionOnly) {
          searchCurrentProjectOnly.checked = false;
          searchSource.value = "";
        }
      }

      // æ•°æ®åŠ è½½å‡½æ•°
      async function loadProjects() {
        suppressUrlSync = true;
        const initial = readUrlState();
        const data = await api("/api/projects");
        state.projects = data.projects || [];
        const desiredKey = makeProjectKey({
          source: initial.source || "claude_code",
          project: initial.project || "",
        });
        const desired = state.projects.find(
          (p) => makeProjectKey({ source: p.source || "claude_code", project: p.project }) === desiredKey
        );
        const first = desired || state.projects[0] || {};
        state.currentProject = { source: first.source || "claude_code", project: first.project || "" };
        state.currentProjectKey = makeProjectKey(state.currentProject);
        renderProjects();
        if (!state.currentProject.project) return;

        if (initial.roles) {
          state.roleFilters = {
            user: initial.roles.has("user"),
            assistant: initial.roles.has("assistant"),
            tool: initial.roles.has("tool"),
            other: initial.roles.has("other"),
          };
        }

        // å¦‚æœ URL æŒ‡å®šäº† session æˆ–è€…ç›´æ¥è¿›å…¥ search è§†å›¾ï¼Œå°±ä¸è¦è‡ªåŠ¨æ‰“å¼€ç¬¬ä¸€ä¸ªä¼šè¯
        const autoOpenFirst = !(initial.sessionId || initial.view === "search" || initial.q);
        await loadSessions(state.currentProject, autoOpenFirst);
        updateSearchScopeUi();

        // è¿˜åŸæœç´¢å‚æ•°
        searchSource.value = initial.searchSource || "";
        searchCurrentProjectOnly.checked = Boolean(initial.projectOnly);
        searchCurrentSessionOnly.checked = Boolean(initial.sessionOnly);

        // å¦‚æœ URL æŒ‡å®šäº† sessionï¼Œåˆ™ä¼˜å…ˆæ‰“å¼€è¯¥ä¼šè¯ï¼ˆå¯å¸¦ offsetï¼‰
        if (initial.sessionId) {
          const overrideOffset = Number.isFinite(initial.offset) ? initial.offset : 0;
          await loadSession(initial.sessionId, false, overrideOffset);
          showSessionView();
          if (initial.focus) scrollToMessage(initial.focus);
          syncUrl({ focus: initial.focus || "" });
          updateSearchScopeUi();
        }

        // å¦‚æœ URL æŒ‡å®šäº†æœç´¢ï¼Œè¿›å…¥æœç´¢è§†å›¾
        if (initial.q) {
          searchInput.value = initial.q;
          await runSearch(false);
          showSearchView();
          syncUrl();
        } else if (initial.view === "search") {
          showSearchView();
          syncUrl();
        }
        suppressUrlSync = false;
      }

      async function loadSessions(projectObj, autoOpenFirst = true) {
        const source = projectObj?.source || "claude_code";
        const project = projectObj?.project || "";
        const data = await api(
          `/api/projects/${encodeURIComponent(project)}/sessions?source=${encodeURIComponent(source)}`
        );
        state.sessions = data.sessions || [];

        // é»˜è®¤å±•å¼€æ‰€æœ‰æœ‰å­ä¼šè¯çš„ä¸»ä¼šè¯
        for (const session of state.sessions) {
          if (!session.parent_session_id) {
            // æ£€æŸ¥æ˜¯å¦æœ‰å­ä¼šè¯
            const hasSubagents = state.sessions.some(s => s.parent_session_id === session.session_id);
            if (hasSubagents) {
              state.expandedSessions.add(session.session_id);
            }
          }
        }

        state.currentSessionId = autoOpenFirst ? (state.sessions[0]?.session_id || "") : "";
        renderSessions();
        renderSessionMeta();
        if (state.currentSessionId) {
          await loadSession(state.currentSessionId);
          return;
        }
        messageList.innerHTML =
          '<div class="text-sm text-slate-400">é€‰æ‹©ä¸€ä¸ªä¼šè¯æŸ¥çœ‹</div>';
        updateSearchScopeUi();
      }

      async function loadSession(sessionId, append = false, overrideOffset = null, urlMode = "replace") {
        state.currentSessionId = sessionId;
        // å¦‚æœä¸æ˜¯è¿½åŠ æ¨¡å¼ï¼Œæ”¯æŒä»æŒ‡å®š offset æ‰“å¼€ï¼ˆç”¨äºæœç´¢è·³è½¬ï¼‰
        // offset æ˜¯ jsonl çš„è¡Œå·åç§»ï¼ˆåç«¯æŒ‰è¡Œæµå¼åˆ†é¡µï¼‰
        const requestedOffset = append ? state.offset : (Number.isFinite(overrideOffset) ? overrideOffset : 0);
        if (!append) {
          state.sessionStartOffset = requestedOffset;
        }
        const source = state.currentProject?.source || "claude_code";
        const project = state.currentProject?.project || "";
        const path = `/api/sessions/${encodeURIComponent(
          sessionId
        )}?project=${encodeURIComponent(project)}&source=${encodeURIComponent(source)}&offset=${
          requestedOffset
        }&limit=${state.limit}`;
        const data = await api(path);
        state.hasMore = Boolean(data.next_offset);
        state.offset = data.next_offset || 0;
        if (!append) {
          messageList.innerHTML = "";
          copyStore.clear();
          copySeq = 0;
        }
        renderSessionMeta();
        renderMessages(data.items || []);
        loadMoreBtn.classList.toggle("hidden", !state.hasMore);
        renderSessions();
        showSessionView();
        if (urlMode === "push") pushUrl();
        else syncUrl();
        updateSearchScopeUi();
      }

      async function runSearch(append = false, urlMode = "replace") {
        const query = searchInput.value.trim();
        state.searchQuery = query;
        if (!query) {
          searchMeta.textContent = "";
          showSessionView();
          if (urlMode === "push") pushUrl();
          else syncUrl();
          return;
        }

        // å¦‚æœä¸æ˜¯è¿½åŠ æ¨¡å¼ï¼Œé‡ç½®æœç´¢çŠ¶æ€
        if (!append) {
          state.searchOffset = 0;
          searchResults.innerHTML = "";
        }

        let path = `/api/search?q=${encodeURIComponent(query)}&offset=${state.searchOffset}&limit=50`;
        // â€œä»…å½“å‰ä¼šè¯â€ä¼˜å…ˆçº§æœ€é«˜
        if (searchCurrentSessionOnly.checked && state.currentProject?.project && state.currentSessionId) {
          path += `&project=${encodeURIComponent(state.currentProject.project)}`;
          path += `&source=${encodeURIComponent(state.currentProject.source || "claude_code")}`;
          path += `&session_id=${encodeURIComponent(state.currentSessionId)}`;
        } else if (searchCurrentProjectOnly.checked && state.currentProject?.project) {
          path += `&project=${encodeURIComponent(state.currentProject.project)}`;
          path += `&source=${encodeURIComponent(state.currentProject.source || "claude_code")}`;
        } else if (searchSource.value) {
          path += `&source=${encodeURIComponent(searchSource.value)}`;
        }
        try {
          const data = await api(path);
          state.searchTotal = data.total || 0;
          state.searchHasMore = data.has_more || false;
          state.searchOffset = data.offset + (data.results?.length || 0);

          searchMeta.textContent = `æ‰¾åˆ° ${state.searchTotal} æ¡ç»“æœï¼Œå·²æ˜¾ç¤º ${state.searchOffset} æ¡`;

          renderSearchResults(data.results || [], append);
          showSearchView();
          if (!append) {
            if (urlMode === "push") pushUrl();
            else syncUrl();
          } else {
            syncUrl();
          }

          // æ˜¾ç¤ºæˆ–éšè—"åŠ è½½æ›´å¤š"æŒ‰é’®
          loadMoreBtn.classList.toggle("hidden", !state.searchHasMore);
        } catch (error) {
          searchMeta.textContent = `æœç´¢é”™è¯¯: ${error.message}`;
          searchResults.innerHTML = `<div class="text-sm text-red-600">${escapeHtml(error.message)}</div>`;
          showSearchView();
          if (!append) {
            if (urlMode === "push") pushUrl();
            else syncUrl();
          } else {
            syncUrl();
          }
        }
      }

      // äº‹ä»¶ç›‘å¬
      projectSelect.addEventListener("change", async (event) => {
        state.currentProjectKey = event.target.value;
        state.currentProject = parseProjectKey(state.currentProjectKey);
        state.offset = 0;
        await loadSessions(state.currentProject);
        pushUrl();
      });

      // äº‹ä»¶å§”æ‰˜ï¼šä¼šè¯åˆ—è¡¨ç‚¹å‡»ï¼ˆæ›¿ä»£é€æ¡ addEventListenerï¼‰
      sessionList.addEventListener("click", (event) => {
        // å¤„ç†å±•å¼€/æŠ˜å æŒ‰é’®ç‚¹å‡»
        const toggleBtn = event.target.closest('[data-action="toggle-subagents"]');
        if (toggleBtn && sessionList.contains(toggleBtn)) {
          event.stopPropagation(); // é˜»æ­¢äº‹ä»¶å†’æ³¡åˆ°æ‰“å¼€ä¼šè¯çš„å¤„ç†å™¨
          const sessionId = toggleBtn.dataset.sessionId || "";
          if (sessionId) {
            // åˆ‡æ¢å±•å¼€çŠ¶æ€
            if (state.expandedSessions.has(sessionId)) {
              state.expandedSessions.delete(sessionId);
            } else {
              state.expandedSessions.add(sessionId);
            }
            // é‡æ–°æ¸²æŸ“ä¼šè¯åˆ—è¡¨
            renderSessions();
          }
          return;
        }

        // å¤„ç†æ‰“å¼€ä¼šè¯ç‚¹å‡»
        const target = event.target.closest('[data-action="open-session"][data-session-id]');
        if (!target || !sessionList.contains(target)) return;
        const sessionId = target.dataset.sessionId || "";
        if (!sessionId) return;
        loadSession(sessionId, false, null, "push").catch(console.error);
      });

      // äº‹ä»¶å§”æ‰˜ï¼šæœç´¢ç»“æœç‚¹å‡»ï¼ˆæ›¿ä»£é€æ¡ addEventListenerï¼‰
      searchResults.addEventListener("click", (event) => {
        const btn = event.target.closest("button[data-action]");
        if (!btn || !searchResults.contains(btn)) return;

        const action = btn.dataset.action || "";
        const sessionId = btn.dataset.session || "";
        const project = btn.dataset.project || "";
        const source = btn.dataset.source || "";
        const timestamp = btn.dataset.timestamp || "";
        const eventId = btn.dataset.eventId || "";
        const lineNo = btn.dataset.lineNo ? Number(btn.dataset.lineNo) : NaN;

        if (!sessionId || !project) return;

        if (action === "jump-to-message") {
          openSessionFromSearch({ sessionId, project, source, eventId, lineNo, timestamp }).catch(console.error);
          return;
        }
        if (action === "open-session") {
          openSessionFromSearch({ sessionId, project, source }).catch(console.error);
        }
      });

      searchBtn.addEventListener("click", () => runSearch(false, "push"));
      clearSearchBtn.addEventListener("click", () => {
        searchInput.value = "";
        state.searchQuery = "";
        searchMeta.textContent = "";
        showSessionView();
        pushUrl();
      });
      searchInput.addEventListener("keydown", (event) => {
        if (event.key === "Enter") {
          runSearch(false, "push");
        }
      });
      loadMoreBtn.addEventListener("click", async () => {
        if (isSearchView()) {
          await runSearch(true);
        } else {
          await loadSession(state.currentSessionId, true);
        }
      });

      searchCurrentSessionOnly.addEventListener("change", () => {
        updateSearchScopeUi();
        syncUrl();
      });
      searchCurrentProjectOnly.addEventListener("change", () => {
        updateSearchScopeUi();
        syncUrl();
      });
      searchSource.addEventListener("change", () => {
        syncUrl();
      });

      // äº‹ä»¶å§”æ‰˜ï¼šåˆ·æ–°æŒ‰é’®ç‚¹å‡»
      sessionMeta.addEventListener("click", async (event) => {
        const expandAllBtn = event.target.closest("#expandAllBtn");
        if (expandAllBtn && sessionMeta.contains(expandAllBtn)) {
          toggleAllDetails(true);
          return;
        }
        const collapseAllBtn = event.target.closest("#collapseAllBtn");
        if (collapseAllBtn && sessionMeta.contains(collapseAllBtn)) {
          toggleAllDetails(false);
          return;
        }

        const refreshBtn = event.target.closest("#refreshSessionBtn");
        if (refreshBtn && sessionMeta.contains(refreshBtn)) {
          // ä¿å­˜å½“å‰ä¼šè¯IDå’Œæ»šåŠ¨ä½ç½®
          const currentSessionId = state.currentSessionId;
          const messageContainer = document.querySelector('.flex-1.min-w-0.overflow-y-auto.p-6');
          const scrollPosition = messageContainer ? messageContainer.scrollTop : 0;

          // åˆ·æ–°æŒ‰é’®çš„è¯­ä¹‰ï¼šé‡æ–°åŠ è½½å½“å‰ä¼šè¯å†…å®¹ï¼ˆä¸åº”è§¦å‘å…¨å±€ç´¢å¼•é‡å»ºï¼‰
          if (currentSessionId) {
            state.currentSessionId = currentSessionId;
            await loadSession(currentSessionId, false, state.sessionStartOffset || 0, "replace");

            // æ¢å¤æ»šåŠ¨ä½ç½®
            if (messageContainer) {
              // ä½¿ç”¨ setTimeout ç¡®ä¿ DOM å·²ç»æ›´æ–°
              setTimeout(() => {
                messageContainer.scrollTop = scrollPosition;
              }, 0);
            }
          }
        }
      });

      // äº‹ä»¶å§”æ‰˜ï¼šrole è¿‡æ»¤ï¼ˆåªå½±å“ä¼šè¯è§†å›¾ï¼‰
      sessionMeta.addEventListener("change", (event) => {
        const input = event.target.closest('input[data-action="role-filter"][data-role]');
        if (!input || !sessionMeta.contains(input)) return;
        const role = input.dataset.role || "";
        if (!role) return;
        state.roleFilters[role] = Boolean(input.checked);
        applyMessageRoleFilter();
        syncUrl();
      });

      // äº‹ä»¶å§”æ‰˜ï¼šå¤åˆ¶ä»£ç å—
      document.addEventListener("click", async (event) => {
        const btn = event.target.closest('button[data-action="copy-code"][data-copy-id]');
        if (!btn) return;

        const copyId = btn.dataset.copyId || "";
        const text = copyStore.get(copyId);
        if (typeof text !== "string") return;

        const original = btn.textContent || "å¤åˆ¶";
        btn.disabled = true;
        const ok = await copyToClipboard(text);
        btn.textContent = ok ? "å·²å¤åˆ¶" : "å¤åˆ¶å¤±è´¥";
        setTimeout(() => {
          btn.textContent = original;
          btn.disabled = false;
        }, 900);
      });

      // äº‹ä»¶å§”æ‰˜ï¼šå¤åˆ¶æ¶ˆæ¯ permalink
      messageList.addEventListener("click", async (event) => {
        const btn = event.target.closest('button[data-action="copy-permalink"][data-event-id]');
        if (!btn || !messageList.contains(btn)) return;
        const eventId = btn.dataset.eventId || "";
        if (!eventId) return;

        // å›ºå®šä¸ºä¼šè¯è§†å›¾é“¾æ¥ï¼Œå¹¶æºå¸¦ focus
        const url = new URL(buildUrl({ focus: eventId }), window.location.origin);
        const ok = await copyToClipboard(url.toString());
        const original = btn.textContent || "ğŸ”—";
        btn.disabled = true;
        btn.textContent = ok ? "å·²å¤åˆ¶" : "å¤±è´¥";
        setTimeout(() => {
          btn.textContent = original;
          btn.disabled = false;
        }, 900);
      });

      // å¤„ç†æµè§ˆå™¨å‰è¿›/åé€€ï¼šå°½é‡è¿˜åŸåˆ° URL å¯¹åº”çš„çŠ¶æ€
      window.addEventListener("popstate", async () => {
        suppressUrlSync = true;
        const u = readUrlState();

        // è¿˜åŸ role filtersï¼ˆURL ä¸å¸¦ roles æ—¶è§†ä¸ºå…¨é€‰ï¼‰
        if (u.roles) {
          state.roleFilters = {
            user: u.roles.has("user"),
            assistant: u.roles.has("assistant"),
            tool: u.roles.has("tool"),
            other: u.roles.has("other"),
          };
        } else {
          state.roleFilters = { user: true, assistant: true, tool: true, other: true };
        }

        const desired = { source: u.source || "claude_code", project: u.project || "" };
        if (desired.project) {
          await ensureProjectLoaded(desired);
        }
        if (u.sessionId) {
          const overrideOffset = Number.isFinite(u.offset) ? u.offset : 0;
          await loadSession(u.sessionId, false, overrideOffset);
          showSessionView();
          if (u.focus) scrollToMessage(u.focus);
        }
        if (u.q) {
          searchInput.value = u.q;
          searchSource.value = u.searchSource || "";
          searchCurrentProjectOnly.checked = Boolean(u.projectOnly);
          searchCurrentSessionOnly.checked = Boolean(u.sessionOnly);
          await runSearch(false);
          showSearchView();
        } else if (u.view === "search") {
          showSearchView();
        } else {
          showSessionView();
        }
        renderSessionMeta();
        applyMessageRoleFilter();
        suppressUrlSync = false;
      });

      // åˆå§‹åŒ–
      loadProjects().catch((error) => {
        messageList.innerHTML = `<div class="text-sm text-red-600">${escapeHtml(
          error.message
        )}</div>`;
      });
    </script>
  </body>
</html>
